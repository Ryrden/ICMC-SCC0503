\documentclass[a4paper, 12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{multicol,lipsum}
\usepackage{hyperref}
\usepackage{minted}

\begin{document}
%\maketitle

\begin{titlepage}
	\begin{center}
	
	%\begin{figure}[!ht]
	%\centering
	%\includegraphics[width=2cm]{c:/ufba.jpg}
	%\end{figure}

		\Huge{Instituto de Ciências Matemáticas e de Computação}\\
		\large{Departamento de Ciências de Computação}\\ 
		\large{SCC0503 - Algoritmos e Estruturas de Dados II}\\ 
		\vspace{15pt}
        \vspace{95pt}
        \textbf{\LARGE{Relatório Exercício 04}}\\
		%\title{{\large{Título}}}
		\vspace{3,5cm}
	\end{center}
	
	\begin{flushleft}
		\begin{tabbing}
			Alunos: Ryan Souza Sá Teles, Silmar Pereira da Silva Junior \\
            NUSP's: 12822062, 12623950.
			Professor: Leonardo Tórtoro Pereira\\
			%Professor co-orientador: \\
	\end{tabbing}
 \end{flushleft}
	\vspace{1cm}
	
	\begin{center}
		\vspace{\fill}
			 Junho\\
		 2022
			\end{center}
\end{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
% % % % % % % % % % % % % % % % % % % % % % % % % %
\newpage
\tableofcontents
\thispagestyle{empty}

\newpage
\pagenumbering{arabic}
% % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Introdução}
O exercício consiste na leitura de dados de quests (missões) de um jogo e na construção de um dígrafo capaz de a simular o caminho de execução delas através da travessia em profundidade do dígrafo.\\
Para realizar tal objetivo foi usada a linguagem de programação java, junto ao paradigma de programação orientada a objetos, pois tal combinação permite a estruturação do código de maneira a torna-ló modular e por conseguinte facilitar a manutenção da codebase e compartilhamento da mesma como um pacote ou reusa-lá em mais projetos.\\

\newpage
\section{Desenvolvimento}

O desenvolvimento do projeto fez uso das abstrações já adotadas em sala de aula e o modelo de dígrafo selecionado para trabalhar foi o de "lista de adjâcencias".\\
Tal decisão foi tomada pela comparação entre a complexidade das operações em comparação com a alternativa (matrix de adjacências) e a frequência com que essas operações são feitas.\\
A principail operação realizada durante o algoritimo é a adição de vertices e arestas, em que a lista é O(1) em ambos, já a matriz é $O(|V|^2)$ e O(1) respectivamente. Com relação as demais ambas as abordagens tem complexidades semelhantes.\\
Outro fator que corroborou para a escolha foi a complexidade de espaço entre as opções, com a lista sendo $O(|V|+|E|)$ enquanto a matrix de adjacências sendo $O(|V|^2)$.\\
Com o objetivo de aplicar as boas práticas de código na atividade, foi criado a classe "Answer" que se tornou classe mãe da Vertex, a qual, possui o método "toString" que imprime na tela cada vertice.\\

Implementação da classe Answer:

\begin{minted}[mathescape, linenos]{java}

public class Answer {
    private int id;
    private String name;
    private String description;
    
    public Answer(int id, String name, String description) {
        this.id = id;
        this.name = name;
        this.description = description;
    }
    
    public int getId() {return id;}
    public String getName() {return name;}
    public String getDescription() {return description;}
    public void setId(int id) {this.id = id;}
    public void setName(String name) {this.name = name;}
    
    public void setDescription(String description) {
        this.description = description;
    }
    public String toString() {
        return "Quest{\n\tID: " + id + "\n\tName: " + name + "\n\tDescription: " + description + "\n}";
    }
}


\end{minted}


Para a implementação do algoritmo de busca em profundidade, por questões didáticas e não de desempenho algorítmico, foi criado o método "getAllConnectedVertex" dentro da classe "DigraphList" e definido seu contrato na interface "GraphInterface", abaixo a implementação:

\begin{minted}[mathescape, linenos]{java}
    public List<Vertex> getAllConnectedVertex(Vertex vertex) {
        if (getAdjacencyList().get(getVertices().indexOf(vertex)).isEmpty()) {
            return Collections.emptyList();
        } else {
            List<Vertex> connectedVertices = new ArrayList<>();
            int vertexIndex = getVertices().indexOf(vertex);
            for (Edge edge : getAdjacencyList().get(vertexIndex)) {
                connectedVertices.add(edge.getDestination());
            }
            return connectedVertices;
        }
    }
\end{minted}

A implementação do algoritmo Depth First Search: 

\begin{minted}[mathescape, linenos]{java}
public void traverseGraph(Vertex source) {
        depthFirstTraversalRecursive(source);
        printPath();
    }

    public void depthFirstTraversalRecursive(Vertex source) {
        int sourceIndex = getGraph().getVertices().indexOf(source);
        addToPath(source);
        markVertexAsVisited(sourceIndex);
        setDistanceToVertex(sourceIndex, 0);
        setPredecessorVertexIndex(sourceIndex, -1);

        List<Vertex> vertexesToVisit = getGraph().getAllConnectedVertex(source);

        for (Vertex currentVisitedVertex : vertexesToVisit) {
            if (!hasVertexBeenVisited(getGraph().getVertices().indexOf(currentVisitedVertex))) {
                depthFirstTraversalRecursive(currentVisitedVertex);
            }
        }
    }
\end{minted}

Como modelo de busca recursiva para o algoritmo, ele sempre vai estar indo do primeiro vertice adicionado como aresta a partir do vértice de origem.

\newpage
\section{Resultados}
Prints do grafo juntamente com sua saída:


Aqui, coloque imagens/tabelas/textos com os resultados, discuta brevemente o que foi obtido.
\newpage
\bibliographystyle{plain}
\bibliography{bibliography.bib}
\newpage
\addcontentsline{toc}{section}{Anexo}
\section*{Anexo}
No anexo, pode colocar qualquer coisa extra que achar interessante: detalhes mais completos de resultados, alguma coisa diferente/inovadora que fez, etc.
\end{document}



